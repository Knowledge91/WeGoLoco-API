//
// Copyright 2016 Amazon.com, Inc. or its affiliates (Amazon). All Rights Reserved.
//
// Code generated by AWS Mobile Hub. Amazon gives unlimited permission to
// copy, distribute and modify it.
//

'use strict';
var AWS = require("aws-sdk");
//var uuid = require('node-uuid');
var docClient = new AWS.DynamoDB.DocumentClient();
var table = "tinpons-mobilehub-1827971537-Users";

function isEmpty(obj) {
    for(var prop in obj) {
        if(obj.hasOwnProperty(prop))
            return false;
    }

    return JSON.stringify(obj) === JSON.stringify({});
}

function respond(context, statusCode, body) {
  let response = {
      statusCode: statusCode,
      headers: {
          "x-custom-header" : "custom header value"
      },
      body: body
  };

  context.succeed(response);
}

console.log("Loading function");

exports.handler = function(event, context, callback) {
    var responseCode = 200;
    var requestBody, pathParams, queryStringParams, headerParams, stage,
    stageVariables, cognitoIdentityId, httpMethod, sourceIp, userAgent,
    requestId, resourcePath, body, user;
    console.log("request: " + JSON.stringify(event));

    // Request Body
    requestBody = event.body;

    if (requestBody !== undefined && requestBody !== null) {

        // Set 'test-status' field in the request to test sending a specific response status code (e.g., 503)
        responseCode = JSON.parse(requestBody)['test-status'];
    }

    // Path Parameters
    pathParams = event.path;

    // Query String Parameters
    queryStringParams = event.queryStringParameters;

    // Header Parameters
    headerParams = event.headers;

    if (event.requestContext !== null && event.requestContext !== undefined) {

        var requestContext = event.requestContext;

        // API Gateway Stage
        stage = requestContext.stage;

        // Unique Request ID
        requestId = requestContext.requestId;

        // Resource Path
        resourcePath = requestContext.resourcePath;

        var identity = requestContext.identity;

        // Amazon Cognito User Identity
        cognitoIdentityId = identity.cognitoIdentityId;

        // Source IP
        sourceIp = identity.sourceIp;

        // User-Agent
        userAgent = identity.userAgent;
    }

    // API Gateway Stage Variables
    stageVariables = event.stageVariables;

    // HTTP Method (e.g., POST, GET, HEAD)
    httpMethod = event.httpMethod;

    // TODO: Put your application logic here...


    var result, params;
    switch (httpMethod) {
      case "GET":
        //var userId = "eu-west-1:ed3670fa-1f3d-40b8-a181-cb48b78fff1c";
        console.log("Check cognitoIdentityId "+cognitoIdentityId)
        var userId = cognitoIdentityId;
        params = {
            TableName: table,
            Key:{
                "userId": userId,
            }
        };

        docClient.get(params, function(err, data) {
            if (err) {
                console.error("Unable to GET user. Error JSON:", JSON.stringify(err, null, 2));
            } else {
                console.log("GET user succeeded:", JSON.stringify(data, null, 2));
                // Strip JSON Root { "Item": ... }
                respond(context, 200, JSON.stringify(data.Item));
            }
        });
        break;
      case "POST":
        user = JSON.parse(requestBody);

        // create user only if not preexisting
        params = {
            TableName: table,
            Key:{
                "userId": cognitoIdentityId,
            }
        };

        docClient.get(params, function(err, data) {
            if (err) {
                console.error("Unable to read item. Error JSON:", JSON.stringify(err, null, 2));
            } else {
              if(Object.keys(data).length === 0 && data.constructor === Object) {
                let date = new Date();
                let isoDate = date.toISOString();
                params = {
                    TableName:table,
                    Item:{
                        "userId" : cognitoIdentityId,
                        "createdAt" : isoDate,
                        "birthdate" : user.birthdate,
                        "email" : user.email,
                        "gender" : user.gender,
                        "tinponCategories" : docClient.createSet(user.tinponCategories),
                        "updatedAt" : isoDate
                    }
                };

                docClient.put(params, function(err, data) {
                    if (err) {
                        console.error("Unable to add item. Error JSON:", JSON.stringify(err, null, 2));
                    } else {
                        console.log("Added item:", JSON.stringify(data, null, 2));
                        body = "Added item:", JSON.stringify(data, null, 2);
                        respond(context, 200, body)
                    }
                });
              } else {
                // User already exists
                body = "User already exists! Cannot create. \n User: "+JSON.stringify(data);
                console.log(body);
                // StausCode 409: conflict
                respond(context, 409, body);
              }
            }
        });
        break;
        case "PUT":
          user = JSON.parse(requestBody);

          // update user only if preexisting
          params = {
              TableName: table,
              Key:{
                  "userId": cognitoIdentityId,
              }
          };

          docClient.get(params, function(err, data) {
              if (err) {
                  console.error("Unable to read item. Error JSON:", JSON.stringify(err, null, 2));
              } else {
                if(Object.keys(data).length === 0 && data.constructor === Object) {
                  // User already exists
                  body = "User does not exist! Cannot update! \n User: "+JSON.stringify(data);
                  console.log(body);
                  // StausCode 409: conflict
                  respond(context, 409, body);
                } else {
                  let user_ = data.Item;
                  let date = new Date();
                  let isoDate = date.toISOString();
                  params = {
                      TableName:table,
                      Item:{
                          "userId" : user_.userId,
                          "createdAt" : user_.createdAt,
                          "birthdate" : user.birthdate,
                          "email" : user.email,
                          "gender" : user.gender,
                          "tinponCategories" : docClient.createSet(user.tinponCategories),
                          "updatedAt" : isoDate
                      }
                  };

                  docClient.put(params, function(err, data) {
                      if (err) {
                          console.error("Unable to update user. Error JSON:", JSON.stringify(err, null, 2));
                      } else {
                          console.log("Updated user:", JSON.stringify(data, null, 2));
                          body = "Updated user:", JSON.stringify(data, null, 2);
                          respond(context, 200, body)
                      }
                  });
                }
              }
          });
          break;
      default:
        // // For demonstration purposes, we'll just echo these values back to the client
        // var responseBody = {
        //     requestBody : requestBody,
        //     pathParams : pathParams,
        //     queryStringParams : queryStringParams,
        //     headerParams : headerParams,
        //     stage : stage,
        //     stageVariables : stageVariables,
        //     cognitoIdentityId : cognitoIdentityId,
        //     httpMethod : httpMethod,
        //     sourceIp : sourceIp,
        //     userAgent : userAgent,
        //     requestId : requestId,
        //     resourcePath : resourcePath
        // };
        //
        // response = {
        //   statusCode: responseCode,
        //   headers: {
        //       "x-custom-header" : "custom header value"
        //   },
        //   body: JSON.stringify(responseBody)
        // };
        // context.succeed(response);
        respond(context, 403, httpMethod+" is not an allowed HTTP method.")
    }
};
